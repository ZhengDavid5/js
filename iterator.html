<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
一 Iterator（遍历器）
主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费
默认 Iterator 接口
原生具备 Iterator 接口的数据结构如下。
Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象


二 默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）
基本应用
const obj = {
[Symbol.iterator] : function () {
return {
next: function () {
return {
value: 1,
done: true
};
}
};
}
};
next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。
一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）,
继承同样会继承这样的方法
<script>
    class RangeIterator {
        constructor(start, stop) {
            this.value = start;
            this.stop = stop;
        }

        [Symbol.iterator]() { return this ;}

        next() {
            var value = this.value;
            if (value < this.stop) {
                this.value++;
                return {done: false, value: value};
            }
            return {done: true, value: undefined};
        }
    }

    function range(start, stop) {
        return new RangeIterator(start, stop);
    }

    for (let value of range(0, 3)) {
        console.log(value); // 0, 1, 2
    }
//继承也可以  使用
    class  people extends RangeIterator{
        constructor(start,stop){
            super(start,stop);
        }
    }

    function range2(start, stop) {
        return new people(start, stop);
    }

    for (let value of range2(0, 3)) {
        console.log(value); // 0, 1, 2
    }
//  类似数组的对象可以调用 数组的symbol.iterator方法
let iterable3={
        0:'a',
        1:'b',
        length:2,//这个条件必须含有
       [Symbol.iterator]:Array.prototype[Symbol.iterator]
}
        for(let item of iterable3){
        console.log("-----demo3"+item)
    }
</script>
3 调用iterator接口的场合
1 解构赋值
对set结构进行解构赋值的时候，会默认调用symbol.iterator
let set=new Set( new Array("a",'b','c'))
let [first,...rest1]=set
console.log("demo 3-1" +first)//a
console.log(rest1)// ["b", "c"]
2扩展运算符
let arr=['b','c']
['a',...arr,'d']// ['a', 'b', 'c', 'd']

3）yield*

yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。
4）其他场合

由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。

for...of
Array.from()
Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
Promise.all()
Promise.race()

4.字符串的iterator接口
<script>
//    var str4=new String('hi');
//  console.log("---demo4_1"+[...str4])
//    str4[String.iterator]=function () {
//      return  {
//          next: function() {
//              if (this._first) {
//                  this._first = false;
//                  return { value: "bye", done: false };
//              } else {
//                  return { done: true };
//            }
//      },
//          _first: true
//    }
//  }
//
//     console.log("---demo4_1"+[...str4])

var str = new String("hi");

[...str] // ["h", "i"]

str[Symbol.iterator] = function() {
    return {
        next: function() {
            if (this._first) {
                this._first = false;
                return { value: "bye", done: false };
            } else {
                return { done: true };
            }
        },
        _first: true
    };
};

console.log([...str]) // ["bye"]
str // "hi"

</script>







</html>