<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <h1> Symbol</h1>
  1.  保证每个属性名称都是独一无二的
    由原来的6种数据结构 undefined  null  Boolean  String  Number Object
    扩展一个Symbol
    </br>
    let s=Symbol()</br>
    console.log(typeof  s)
    //symbol    </br></br>
    <script>
        let demo1=Symbol()
        console.log("demo1"+typeof  demo1)
    </script>
  2. Symbol前不能使用new 会报错  它是类似字符串的数据类型  无法添加属性</br>
       Symbol函数可以接受一个字符串作为参数 主要来描述Symbol实例 在控制台种能够区分</br>
       如果参数事对象  就会调用对象的toString方法 生成一个Symbol</br>
       即使两个参数相同Symbol的返回值也是不相等的</br>
       Symbol值不能与其他值进行运算 会报错   console.log("string"+symbol) 都会报错</br>
       可以显式的转成字符串</br>
       可以转成布尔值，但不能转为数值(Number(stmbol)//会报错)</br>
    const obj = {</br>
    toString() {</br>
    return 'abc';</br>
    }</br>
    };</br>
    let s1 = Symbol('foo');</br>
    s1.toString() // "Symbol(foo)"</br>
    const sym = Symbol(obj);</br>
    sym // Symbol(abc)</br>
    3.作为属性名的symbol基础用法     不能使用.运算符(例如xx.mySymbol )  let symbol = Symbol('size')typeof this[symbol] 为值 typeof size 为 symbol   注意  .后面只能接字符串
    用于对象的属性，保证不会出现相同的属性</br>
    命名方式</br>
    let mySymbol=Symbol()</br>
    //第一种</br>
    let a={}</br>
    a[mySymbol]='hello'</br>
    //第二种</br>
    let a={</br>
    [mySymbol]:'hello'</br>
    }</br>
    //第三种</br>
    let a={};</br>
    Object.defineProperty(a,mySymbol,{value:'hello'})</br>

    //demo   使用.运算符的结果
    const mySymbol=Symbol();</br>
    demo3.mySymbol='hello122'</br>
    console.log("demo3"+demo3.mySymbol+"----"+typeof demo3.mySymbol)//demo3hello122----string</br>
    console.log("demo3"+demo3[mySymbol]+"----"+typeof demo3[mySymbol] )//demo3undefined----undefined</br>
    console.log("demo3"+demo3['mySymbol']+"----"+typeof demo3['mySymbol'])//demo3hello122----string</br>
    </br>

<script>
    let mySymbol=Symbol()
    //第一种
    let a={}
    a[mySymbol]='hello'
    //第二种
//    let a={
//        [mySymbol]:'hello'
//    }
    //第三种
//    let a={};
//    Object.defineProperty(a,mySymbol,{value:'hello'})
    console.log(a[mySymbol])
    let demo3={};
     demo3.mySymbol='hello122'
    console.log("demo3"+demo3.mySymbol+"----"+typeof demo3.mySymbol)
    console.log("demo3"+demo3[mySymbol]+"----"+typeof demo3[mySymbol] )
    console.log("demo3"+demo3['mySymbol']+"----"+typeof demo3['mySymbol'])
</script>
     4   如何取值 </br>
    4.1 不会出现在for...in,for...of循环种也不会Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，</br>
    4.2 同时也不是私有属性(Object.getOwnPropertyNames(obj)获取不到)，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</br>
    4.3  Reflect.ownKeys(obj4)   可以获取obj4种的所有symbol值(数组)  </br>
    4.4 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。  </br>
    let obj4={}</br>
    let a4=Symbol('a')</br>
    let b4=Symbol('b')</br>
    obj4[a4]='hello';</br>
    obj4[b4]='world'</br>
    let objSymbol4=Object.getOwnPropertySymbols(obj4)</br>
    console.log(Reflect.ownKeys(obj4))//[Symbol(a), Symbol(b)]</br>
  4.4
    let x = new Collection();</br>
    Collection.sizeOf(x) // 0</br>
    x.add('foo');</br>
    console.log(Collection.sizeOf(x)) // 1</br>
    console.log( Object.keys(x) )// ['0']</br>
    console.log( Object.getOwnPropertyNames(x) ) // ['0']</br>
    console.log( Object.getOwnPropertySymbols(x) )//[Symbol(size)]</br>
<script>
    let obj4={}
    let a4=Symbol('a')
    let b4=Symbol('b')
    obj4[a4]='hello';
    obj4[b4]='world'
    let objSymbol4=Object.getOwnPropertySymbols(obj4)
    objSymbol4.forEach((item)=>{
        console.log(item);
    })
    console.log(Reflect.ownKeys(obj4))//[Symbol(a), Symbol(b)]

    let size = Symbol('size');

    class Collection {
        constructor() {
            this[size] = 0;
        }

        add(item) {
            this[this[size]] = item;
            this[size]++;
        }

        static sizeOf(instance) {
            return instance[size];
        }
    }




</script>


</head>
<body>
<script>
</script>
</body>
</html>