<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generator 函数的异步应用</title>
</head>
<body>
一.</br>
ES6 诞生以前，异步编程的方法，大概有下面四种。</br>
回调函数</br>
事件监听</br>
发布/订阅</br>
Promise 对象</br>
<script>
//  发布订阅了解一波
    var pubsub =( ()=>{
            var q = {}
           topics = {},
               subUid = -1;
            //发布消息
        q.publish = function(topic, args) {
            if(!topics[topic]) {return;}
            var subs = topics[topic],
                len = subs.length;
            while(len--) {
                subs[len].func(topic, args);
            }
            return this;
        };
        //订阅事件
        q.subscribe = function(topic, func) {
            topics[topic] = topics[topic] ? topics[topic] : [];
            var token = (++subUid).toString();
            topics[topic].push({
                token : token,
                func : func
            });
            return token;
        };
        return q;
        })();
    //触发的事件

    var logmsg = function(topics, data) {
        console.log("logging:" + topics + ":" + data);
    }
    //监听指定的消息'msgName'
    var sub = pubsub.subscribe('msgName', logmsg);
    //发布消息'msgName'
    pubsub.publish('msgName', 'hello world');
    //发布无人监听的消息'msgName1'
    pubsub.publish('anotherMsgName', 'me too!');
</script>
</br>
2 Generator 函数的数据交换和错误处理 §</br>
Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。</br>
除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制</br>
<script>
    console.log("=========2_2   函数体内外数据的交换")
    function* gen2_2( x) {
        var y=yield x+2
        return y
    }
    var g=gen2_2(1)
   console.log(g.next()) //3
    console.log(g.next(2))//2 没有return y  就是undefined
    console.log("=========2_23   错误处理机制")
    function * gen2_3(x) {
        try{
            let y=yield x+2
        }catch (e){
            console.log(e)
        }
    }
    let g2_3=gen(1)
    gen2_3.next();
    gen2_3.throw("出错了")
</script>
3. 异步任务的封装</br>
//以下不是很方便  只是演示一个异步的任务
var fetch = require('node-fetch');</br>
function* gen(){</br>
var url = 'https://api.github.com/users/github';</br>
var result = yield fetch(url);</br>
console.log(result.bio);</br>
}</br>
var g = gen();</br>
var result = g.next();</br>
result.value.then(function(data){           //fetch模块返回的是一个promise对象  因此要用then 方法调用下一个next放</br>
return data.json();</br>
}).then(function(data){</br>
g.next(data);</br>
});</br>
4.  thunk 函数</br>
Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</br>

简易的demo</br>
fs.readFile(fileName, callback);</br>
// Thunk版本的readFile（单参数版本）</br>
var Thunk = function (fileName) {</br>
return function (callback) {</br>
return fs.readFile(fileName, callback);</br>
};</br>
};</br>
var readFileThunk = Thunk(fileName);</br>
readFileThunk(callback);</br>
<script>
    //Thrunk函数转换器
    // ES5版本
    var Thunk = function(fn){
        return function (){
            var args = Array.prototype.slice.call(arguments);
            return function (callback){
                args.push(callback);
                return fn.apply(this, args);
            }
        };
    };
    // ES6版本
    const Thunk = function(fn) {
        return function (...args) {
            return function (callback) {
                return fn.call(this, ...args, callback);
            }
        };
    };

    function f(a, cb) {
        cb(a);
    }
    const ft = Thunk(f);
    ft(1)(console.log) // 1
</script>
Thunkify 模块
生产环境的转换器，建议使用 Thunkify 模块。
$ npm install thunkify


</body>
</html>