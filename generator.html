<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
4   Generator.prototype.throw()</br>
throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。，否则 Generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部。</br>
throw方法被捕获以后，会附带执行下一条yield表达式。</br>

<script>
    var g = function* () {
        try {
            yield;
        } catch (e) {
            console.log('内部捕获', e);
        }
    };
    let i4=g()
   console.log(i4.next())
    try{
        i4.throw(new Error('出错了'))
        i4.throw('a')
        i4.throw('b')
    }catch (e){
        console.log('外部捕获'+e)
    }
    //内部捕获 Error: 出错了  外部捕获a
    //第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，
    // 不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。


    //throw方法被捕获以后，会附带执行下一条yield表达式
    var gen = function* gen(){
        try {
            yield console.log('a');
        } catch (e) {
            // ...
            console.log(e)
        }
        yield console.log('b');
        yield console.log('c');
    }
    var g = gen();
    g.next() // a
    g.throw() // undefined   b
    g.next()// c

    function* g2() {
        yield 1;
        console.log('throwing an exception');
        throw new Error('generator broke!');
        yield 2;
        yield 3;
    }

    function log(generator) {
        var v;
        console.log('starting generator');
        try {
            v = generator.next();
            console.log('第一次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        try {
            v = generator.next();
            console.log('第二次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        try {
            v = generator.next();
            console.log('第三次运行next方法', v);
        } catch (err) {
            console.log('捕捉错误', v);
        }
        console.log('caller done');
    }

    log(g2());
    // starting generator
    // 第一次运行next方法 { value: 1, done: false }
    // throwing an exception
    // 捕捉错误 { value: 1, done: false }  为什么会是1  不懂
    // 第三次运行next方法 { value: undefined, done: true }
    // caller done

</script>
5  Generator.prototype.return()</br>
return方法，可以返回给定的值，并且终结遍历 Generator 函数。</br>
try...finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行。</br>

<script>
    console.log("=================5 .1")
    function* numbers () {
        yield 1;
        let x;
        try {
            yield  x=2;//说明赋值的也是将2返回了
            yield 3;
        } finally {
            yield 4;
            yield 5;
        }
        yield 6;
    }
    var g5 = numbers();
    console.log(g5.next())// { value: 1, done: false }
    console.log(g5.next()) // { value: 2, done: false }
    console.log(g5.return(7)) // { value: 4, done: false }
    console.log(g5.next()) // { value: 5, done: false }
    console.log(g5.next()) // { value: 7, done: true }

</script>
7. yield* 表达式</br>
1  如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。7.1 7.2</br>
   这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。  yield 加函数的话  返回的是遍历器对象  </br>
2.实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。 如数组。7.3  便利二叉树略去了</br>
<script>
    console.log("=================7.1")
    function* foo7_1() {
        yield 'a', yield  'b'
    }
    function* bar7_1() {
        yield 'x'
        yield* foo7_1()// 等同于for (let v of foo()) {  yield v;   }
        yield  'y'
    }
     for(let item of bar7_1()){
        console.log(item)  //x,a,b,y
     }
    console.log("=================7.2")
    function*  gen7_2() {
        yield   ['1','2']
        yield * ['1','2']
        yield 'hello';
        yield* 'hello';
    }
    let tem7_2=gen7_2()
    console.log(tem7_2.next())//{value: Array(2), done: false}
    console.log(tem7_2.next())//{value: "1", done: false}
    console.log(tem7_2.next())//{value: "2", done: false}
    console.log(tem7_2.next())//{value: "hello", done: false}
    console.log(tem7_2.next())//{value: "h", done: false}
    console.log("=================7.3")
    function* genFuncWithReturn7_3() {
        yield 'a';
        yield 'b';
        return 'The result';
    }
    function* logReturned7_3(genObj) {
        let result = yield* genObj;
        console.log(result);
    }
    console.log([...logReturned7_3(genFuncWithReturn7_3())])
    console.log("=================7.4")
    function* iterArry7_4(tree) {
        if(Array.isArray(tree)){
            for (let i=0;i<tree.length;i++){
                yield* iterArry7_4(tree[i])
            }
        }else {
            yield  tree
        }
    }
    const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];
    console.log(...iterArry7_4(tree))
</script>
8 作为对象属性的generator函数</br>
let obj = {</br>
* myGeneratorMethod() {</br>
···</br>
}</br>
};</br>
等价于</br>
let obj = {</br>
myGeneratorMethod: function* () {</br>
// ···</br>
}</br>
};</br>
9.Generator 函数的this
1.Generator 函数总是返回一个遍历器对象，不是this对象  ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法</br>
  且不能和new一起用  demo g9_2  </br>
  正常拿到this  通过。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</br>
<script>
    console.log("=================9-1   " )
    function* g9_1() {
        this.a=11
    }
    g9_1.prototype.hello = function () {
        return 'hi!';
    };
    let obj9_1 = g9_1();
    console.log(obj9_1 instanceof g9_1) // true
    console.log(obj9_1.hello()) // 'hi!'
    console.log(obj9_1.a)//undefined
    console.log("=================9-2 " )
    function* gen() {
        this.a = 1;
        yield this.b = 2;
        yield this.c = 3;
    }

    function F() {
        return gen.call(gen.prototype);
    }

    var f = new F();

    f.next();  // Object {value: 2, done: false}
    // f.a=1   f .hasOwnProperty('a')    false  说明这个a挂载在原型上 并不是挂载在实例上
//    function x() {
//        this.a=2
//    }
//    let s=   new  x()//f .hasOwnProperty('a')
    f.next();  // Object {value: 3, done: false}
    f.next();  // Object {value: undefined, done: true}
    f.a // 1
    f.b // 2
    f.c // 3
</script>

</body>
</html>