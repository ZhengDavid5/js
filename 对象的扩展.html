<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        p{ white-space: pre-line;}
    </style>
</head>
<body>
<p>
一    对象的新增方法
   1.Object.is()
    ES5: 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。
    它们都有缺点，前者会自动转换数据类型，
    后者的NaN不等于自身，以及+0等于-0。
    JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
    ES6: 提出“Same-value equality”（同值相等）算法,Object.is就是部署这个算法的新方法,
    它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
    不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
</p>
<script>{
    +0 === -0 //true
    NaN === NaN // false
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true
}
</script>
<p>
  二  Object.assign()
    基本用法
    Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
</p>
<script>
    {
      let  target={a:1}
      let  source1={b:2}
      let  source2={c:3}
      Object.assign(target,source1,source2)
      console.log(target)// {a:1, b:2, c:3}
    }
</script>
<p>
  二.1  注意点
     1.目标对象与元对象有同名属性或者多个源对象有同名属性，则后面的属性会覆盖前面的属性
     2.如果只有一个参数，Object.assign会直接返回该参数,后面不管加多少参数都是原对象
     3.如果该参数不是对象，则会先转成对象，然后返回。
     4.由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
     5.undefined和null不出现在首参数，不会报错
     6.其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。
       但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
       因为只有字符串  能包装成对象
     7.Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
      属性名为 Symbol 值的属性，也会被Object.assign拷贝。
     8. 属于浅拷贝 如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
     9.数组的处理  会把数组当成对象处理
     10.取值函数的处理  如果复制的值是一个取值函数,那么将求值后再复制
</p>
<script>
    //1
    {
        let target={a:2,b:3}
        let source1={a:4}
        Object.assign(target,source1)
        console.log(target)//{a: 4, b: 3}
    }
    //2
    {
        let target={a:2,b:3}
        let source1={a:4,c:5}
        let obj={ss:555}
        console.log(target===Object.assign(target,source1))
        console.log(Object.assign(obj) === obj )// true
        console.log(target)//{a: 4, b: 3}
    }
    //3
    {
      console.log(typeof Object.assign(2) )// "object"
    }
    //4
    {
       // Object.assign(undefined) // 报错
       // Object.assign(null) // 报错
    }
    //5
    {

        let obj = {a: 1};
        console.log( Object.assign(obj, undefined) === obj )// true
        console.log( Object.assign(obj, null) === obj )// true
    }
    //6
    {
         let s1='abc'
         let s2=true
         let s3=10
        let obj=Object.assign({},s1,s2,s3)
        console.log(obj)// { "0": "a", "1": "b", "2": "c" }
        console.log(Object('abc'))// {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
    }
   //7
    {
      console.log(
          Object.assign({b: 'c'},
          Object.defineProperty({}, 'invisible', {
              enumerable: false,
              value: 'hello'
          })
      ))  // { b: 'c' }
        Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' })// { a: 'b', Symbol(c): 'd' }
    }
    //8
    {
        let obj={a:{b:1}}
        let obj2=Object.assign({},obj)
        obj.a.b=2
        console.log(obj2.a.b)//2
    }
     //9
    {
        console.log(Object.assign([1,2,3,],[4,5]))
        //[4,5,3]  把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1
    }
     //10
    {
        let  source = {
            get foo() { return 1 }
        };
        let target = {};
        console.log(Object.assign(target, source))//// { foo: 1 }
    }
</script>
<p>
  三  常见用途
    1.为对象添加属性
    2.为对象添加方法
    3.克隆对象    不过只能克隆对象自身的值 ，不能克隆它继承的值注意中的
    4.合并对个对象，将多个对象合并
    5.为属性指定默认值
</p>
<script>
    //1
   {
    class Point{
        constructor(x,y){
            Object.assign(this,{x,y})
        }
    }
    let ss=new Point(2,3)
    console.log(ss)//Point {x: 2, y: 3}
    }
    //2
    {
        class Point{}
        Object.assign(Point,{doSome(){
            console.log("doSome")
        }})
        Point.doSome()
    }
    // 3 克隆并被克隆集成的值  如果想保持继承链
    {
       // 有待详细
//        function clone(origin) {
//            let originProto = Object.getPrototypeOf(origin);
//            return Object.assign(Object.create(originProto), origin);
//        }
    }
   //5
    {
        let  DEFAULTS = {
            logLevel: 0,
            outputFormat: 'html'
        };

        function processContent(options) {
            options = Object.assign({}, DEFAULTS, options);
            console.log(options);
            // ...
        }
        processContent({logLevel:2})//{logLevel: 2, outputFormat: "html"}
    }

</script>
<p>
四.    es5   Object.getOwnPropertyDescriptor()  会返回某个对象属性的描述对象  某个单个的
       es6   Object.getOwnPropertyDescriptors()  返回指定对下个所有自身属性(非继承属性的描述对象)
       目的  主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。  所有的
</p>
<script>
    //两个方法的基础用法
    {
        let source={
            set foo(value){
                console.log(value)
            },
            s:1
        }
        let  target={}
        console.log("-------------")
        console.log( Object.getOwnPropertyDescriptor(source))//undefined
        console.log( Object.getOwnPropertyDescriptor(source,'s'))//{value: 1, writable: true, enumerable: true, configurable: true}
        console.log( Object.getOwnPropertyDescriptors(source))
        //{foo: {…}, s: {…}}
       //   foo: {get: undefined, set: ƒ, enumerable: true, configurable: true}
      //  s: {value: 1, writable: true, enumerable: true, configurable: true}
       // __proto__: Object
        console.log( Object.getOwnPropertyDescriptors(source,'s'))//同上
    }
    //返回整个对象属性的描述对象
    {
        let  obj={
            foo:123,
            get  bar(){
                return  'c'
            }
        }
        console.log(obj.bar)//c
        console.log(Object.getOwnPropertyDescriptor(obj))//返回所有元对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象
      //  {foo: {…}, bar: {…}}
     //   bar:configurable: true
     //   enumerable: true
    //    get: ƒ bar()
      //  set: undefined
     //   __proto__: Object
     //   foo: {value: 123, writable: true, enumerable: true, configurable: true}
     //   __proto__: Object
        console.log(Object.getOwnPropertyDescriptors(obj))//与上面一样
    }

    //   无法拷贝get  set属性的方法
    {
    let source={
         set foo(value){
             console.log(value)
         }
    }
        let target={}
        Object.assign(target,source)
      console.log(Object.getOwnPropertyDescriptor(target,'foo'))
        // { value: undefined,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true }
        //Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。所以value为undefined
    }
    // 用途一   解决浅拷贝的问题   Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。
    {
        let source={
            set foo(value){
                console.log(value)
            },
            s:1
        }
      let  target={}
       console.log( Object.getOwnPropertyDescriptor(source))
        console.log( Object.getOwnPropertyDescriptors(source))
       Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))
        console.log(Object.getOwnPropertyDescriptor(target,"foo"))
        //{get: undefined, set: ƒ, enumerable: true, configurable: true}
    }
     //用途二  是配合Object.create()方法，将对象属性克隆到一个新对象

    {


    }


</script>
</body>
</html>